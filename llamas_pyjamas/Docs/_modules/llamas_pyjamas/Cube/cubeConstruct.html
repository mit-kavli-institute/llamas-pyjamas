

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>llamas_pyjamas.Cube.cubeConstruct &mdash; llamas-pyjamas 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            llamas-pyjamas
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">llamas-pyjamas</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">llamas_pyjamas.Cube.cubeConstruct</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for llamas_pyjamas.Cube.cubeConstruct</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for constructing 3D IFU data cubes from extracted fiber spectra.</span>

<span class="sd">This module provides the CubeConstructor class which takes extracted wavelength data</span>
<span class="sd">from multiple fibers across different detectors and reconstructs a full 3D data cube</span>
<span class="sd">with spatial (x,y) and spectral (λ) dimensions.</span>

<span class="sd">The module supports two modes of operation:</span>
<span class="sd">1. Processing a single RSS file containing all channels</span>
<span class="sd">2. Processing multiple channel-specific RSS files with names like:</span>
<span class="sd">   &quot;_extract_RSS_blue.fits&quot;, &quot;_extract_RSS_green.fits&quot;, &quot;_extract_RSS_red.fits&quot;</span>

<span class="sd">Classes:</span>
<span class="sd">    CubeConstructor: Main class for IFU cube reconstruction from extraction data.</span>

<span class="sd">Dependencies:</span>
<span class="sd">    - numpy</span>
<span class="sd">    - scipy</span>
<span class="sd">    - astropy</span>
<span class="sd">    - matplotlib</span>
<span class="sd">    - llamas_pyjamas modules</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy.wcs</span> <span class="kn">import</span> <span class="n">WCS</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">LinearNDInterpolator</span><span class="p">,</span> <span class="n">RegularGridInterpolator</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="c1"># Import LLAMAS modules</span>
<span class="kn">from</span> <span class="nn">llamas_pyjamas.Image.WhiteLightModule</span> <span class="kn">import</span> <span class="n">FiberMap_LUT</span>
<span class="kn">from</span> <span class="nn">llamas_pyjamas.Image.processWhiteLight</span> <span class="kn">import</span> <span class="n">quartile_bias</span><span class="p">,</span> <span class="n">remove_striping</span>
<span class="kn">from</span> <span class="nn">llamas_pyjamas.config</span> <span class="kn">import</span> <span class="n">OUTPUT_DIR</span><span class="p">,</span> <span class="n">LUT_DIR</span>
<span class="kn">from</span> <span class="nn">llamas_pyjamas.Utils.utils</span> <span class="kn">import</span> <span class="n">setup_logger</span>


<div class="viewcode-block" id="CubeConstructor">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor">[docs]</a>
<span class="k">class</span> <span class="nc">CubeConstructor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for constructing 3D IFU data cubes from extracted fiber spectral data.</span>
<span class="sd">    </span>
<span class="sd">    This class takes extraction files containing wavelength-calibrated spectra from </span>
<span class="sd">    individual fibers across multiple detectors and reconstructs them into a unified</span>
<span class="sd">    3D data cube with spatial (x,y) and spectral (wavelength) dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        fiber_map_path (str): Path to the fiber mapping lookup table</span>
<span class="sd">        fibermap_lut (Table): Loaded fiber mapping table</span>
<span class="sd">        logger (Logger): Logger instance for debugging and info</span>
<span class="sd">        cube_data (np.ndarray): The reconstructed 3D data cube [λ, y, x]</span>
<span class="sd">        wavelength_grid (np.ndarray): Wavelength axis of the cube</span>
<span class="sd">        spatial_grid_x (np.ndarray): X spatial coordinates</span>
<span class="sd">        spatial_grid_y (np.ndarray): Y spatial coordinates</span>
<span class="sd">        wcs (WCS): World coordinate system for the cube</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="CubeConstructor.__init__">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fiber_map_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the CubeConstructor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            fiber_map_path (str, optional): Path to fiber mapping file. If None, uses default.</span>
<span class="sd">            logger (Logger, optional): Logger instance. If None, creates new one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set up fiber mapping</span>
        <span class="k">if</span> <span class="n">fiber_map_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fiber_map_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">LUT_DIR</span><span class="p">,</span> <span class="s1">&#39;LLAMAS_FiberMap_rev04.dat&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fiber_map_path</span> <span class="o">=</span> <span class="n">fiber_map_path</span>
            
        <span class="c1"># Load fiber mapping table</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fibermap_lut</span> <span class="o">=</span> <span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fiber_map_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;ascii.fixed_width&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not load fiber map from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fiber_map_path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set up logging</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">_%H%M%S&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;CubeConstruct_</span><span class="si">{</span><span class="n">timestamp</span><span class="si">}</span><span class="s1">.log&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
            
        <span class="c1"># Initialize cube data attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;CubeConstructor initialized successfully&quot;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="CubeConstructor.load_rss_data">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.load_rss_data">[docs]</a>
    <span class="k">def</span> <span class="nf">load_rss_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rss_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load extraction data from RSS FITS file format.</span>

<span class="sd">        New RSS file format:</span>
<span class="sd">        Extension 0 - PRIMARY: primary header only, no data</span>
<span class="sd">        Extension 1 - FLUX: extracted fiber flux [NWAVE x NFIBER]</span>
<span class="sd">        Extension 2 - ERROR: the error array [NWAVE x NFIBER]</span>
<span class="sd">        Extension 3 - MASK: the pixel mask array [NWAVE x NFIBER]</span>
<span class="sd">        Extension 4 - WAVE: the wavelength array for each fiber [NWAVE x NFIBER]</span>
<span class="sd">        Extension 5 - FWHM: the full width half max array [NWAVE x NFIBER]</span>
<span class="sd">        Extension 6 - FIBERMAP: the complete fibermap [BINARY FITS TABLE]</span>

<span class="sd">        Parameters:</span>
<span class="sd">            rss_file (str): Path to RSS FITS file</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[List[Dict], List[Dict]]: List of extraction data dictionaries and metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading RSS data from </span><span class="si">{</span><span class="n">rss_file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">extractions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">rss_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdul</span><span class="p">:</span>
            <span class="c1"># Get channel from primary header</span>
            <span class="n">primary_hdr</span> <span class="o">=</span> <span class="n">hdul</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">primary_hdr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">,</span> <span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            
            <span class="c1"># Initialize extraction dictionary</span>
            <span class="n">extraction</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span>
                <span class="s1">&#39;flux&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;mask&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;fwhm&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;fibermap&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;benchside&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
            
            <span class="c1"># Process all extensions</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hdul</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">extname</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;FLUX&#39;</span><span class="p">:</span>
                        <span class="c1"># FLUX: [NWAVE x NFIBER] array</span>
                        <span class="n">flux</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded FLUX extension with shape </span><span class="si">{</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Transpose to [NFIBER x NWAVE] for internal processing</span>
                        <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">T</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">:</span>
                        <span class="c1"># ERROR: [NWAVE x NFIBER] array</span>
                        <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded ERROR extension with shape </span><span class="si">{</span><span class="n">error</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Transpose to [NFIBER x NWAVE] for internal processing</span>
                        <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">T</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;MASK&#39;</span><span class="p">:</span>
                        <span class="c1"># MASK: [NWAVE x NFIBER] array</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded MASK extension with shape </span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Transpose to [NFIBER x NWAVE] for internal processing</span>
                        <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">T</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;WAVE&#39;</span><span class="p">:</span>
                        <span class="c1"># WAVE: [NWAVE x NFIBER] array</span>
                        <span class="n">wave</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded WAVE extension with shape </span><span class="si">{</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Transpose to [NFIBER x NWAVE] for internal processing</span>
                        <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wave</span><span class="o">.</span><span class="n">T</span>
                        
                        <span class="c1"># Also create a common wavelength grid as the median across all fibers</span>
                        <span class="c1"># This is useful for operations that need a single wavelength grid</span>
                        <span class="n">wave_common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Median across fibers for each wavelength point</span>
                        <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave_common&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wave_common</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created common wavelength grid with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">wave_common</span><span class="p">)</span><span class="si">}</span><span class="s2"> points&quot;</span><span class="p">)</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;FWHM&#39;</span><span class="p">:</span>
                        <span class="c1"># FWHM: [NWAVE x NFIBER] array</span>
                        <span class="n">fwhm</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded FWHM extension with shape </span><span class="si">{</span><span class="n">fwhm</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># Transpose to [NFIBER x NWAVE] for internal processing</span>
                        <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhm</span><span class="o">.</span><span class="n">T</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;FIBERMAP&#39;</span><span class="p">:</span>
                        <span class="c1"># FIBERMAP: binary table with fiber information</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="p">):</span>
                            <span class="c1"># Create a dictionary for fiber metadata</span>
                            <span class="n">fibermap</span> <span class="o">=</span> <span class="p">{}</span>
                            <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">hdu</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                <span class="n">col_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                                
                                <span class="c1"># Convert any byte strings to regular strings</span>
                                <span class="k">if</span> <span class="n">col_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                                    <span class="n">col_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span> 
                                                      <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">col_data</span><span class="p">])</span>
                                
                                <span class="n">fibermap</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_data</span>
                            
                            <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;fibermap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibermap</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded FIBERMAP with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fibermap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;FIBER_ID&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">[]))</span><span class="si">}</span><span class="s2"> entries&quot;</span><span class="p">)</span>
                            
                            <span class="c1"># Extract BENCHSIDE information if available</span>
                            <span class="k">if</span> <span class="s1">&#39;BENCHSIDE&#39;</span> <span class="ow">in</span> <span class="n">fibermap</span><span class="p">:</span>
                                <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;benchside&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibermap</span><span class="p">[</span><span class="s1">&#39;BENCHSIDE&#39;</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted BENCHSIDE information from FIBERMAP&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIBERMAP extension is not a binary table&quot;</span><span class="p">)</span>
                
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading data from </span><span class="si">{</span><span class="n">extname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Validate the loaded data</span>
            <span class="k">if</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No FLUX data found in RSS file for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add the extraction to the list</span>
                <span class="n">extractions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extraction</span><span class="p">)</span>
                
                <span class="c1"># Create metadata entry</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span>
                    <span class="s1">&#39;benchside&#39;</span><span class="p">:</span> <span class="n">extraction</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;benchside&#39;</span><span class="p">,</span> <span class="p">[]),</span>
                    <span class="s1">&#39;nfibers&#39;</span><span class="p">:</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="p">}</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added extraction for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nfibers&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> fibers&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">extractions</span><span class="p">,</span> <span class="n">metadata</span></div>


<div class="viewcode-block" id="CubeConstructor.get_fiber_coordinates">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.get_fiber_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_fiber_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">benchside</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the physical x,y coordinates for a given fiber.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            benchside (str): Bench and side identifier (e.g., &#39;1A&#39;, &#39;2B&#39;)</span>
<span class="sd">            fiber_num (int): Fiber number or fiber ID from FIBERMAP extension</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: (x, y) coordinates, or (-1, -1) if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FiberMap_LUT</span><span class="p">(</span><span class="n">benchside</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Fallback to direct table lookup</span>
            <span class="n">fiber_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fibermap_lut</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fibermap_lut</span><span class="p">[</span><span class="s1">&#39;bench&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">benchside</span><span class="p">,</span> 
                              <span class="bp">self</span><span class="o">.</span><span class="n">fibermap_lut</span><span class="p">[</span><span class="s1">&#39;fiber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">fiber_num</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fiber_row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">fiber_row</span><span class="p">[</span><span class="s1">&#39;xpos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">fiber_row</span><span class="p">[</span><span class="s1">&#39;ypos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span></div>

    
<div class="viewcode-block" id="CubeConstructor.map_pixel_to_sky">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.map_pixel_to_sky">[docs]</a>
    <span class="k">def</span> <span class="nf">map_pixel_to_sky</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">benchside</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pixel_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">pixel_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                         <span class="n">wavelength</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map detector pixel coordinates to sky coordinates.</span>
<span class="sd">        </span>
<span class="sd">        This implementation uses the fact that each fiber corresponds to 0.75&quot; on the sky.</span>
<span class="sd">        It uses the fiber’s nominal position (from the fiber map) as a base, adds an offset computed</span>
<span class="sd">        from the input detector pixel coordinates scaled by 0.75&quot; per pixel, and then translates</span>
<span class="sd">        the result into sky coordinates using the RA and DEC from the primary header (stored in the WCS).</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            benchside (str): Bench and side identifier (e.g., &#39;1A&#39;, &#39;2B&#39;)</span>
<span class="sd">            fiber_num (int): Fiber number</span>
<span class="sd">            pixel_x (int): Detector pixel X offset (in pixels) from the fiber center</span>
<span class="sd">            pixel_y (int): Detector pixel Y offset (in pixels) from the fiber center</span>
<span class="sd">            wavelength (float): Wavelength in Angstroms (currently not used in the mapping)</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: (ra, dec) sky coordinates in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the nominal fiber center (in IFU focal plane arcsec)</span>
        <span class="n">fiber_x</span><span class="p">,</span> <span class="n">fiber_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fiber_coordinates</span><span class="p">(</span><span class="n">benchside</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fiber_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">fiber_y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid fiber coordinates for </span><span class="si">{</span><span class="n">benchside</span><span class="si">}</span><span class="s2"> fiber </span><span class="si">{</span><span class="n">fiber_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Retrieve reference (RA, DEC) from the primary header via the WCS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="s1">&#39;wcs&#39;</span><span class="p">):</span>
            <span class="n">ra_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dec_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WCS is not available; defaulting to (0.0, 0.0) for reference coordinates&quot;</span><span class="p">)</span>
            <span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

        <span class="c1"># Convert the detector pixel offset to arcseconds using the 0.75&quot; scale</span>
        <span class="n">delta_x_arcsec</span> <span class="o">=</span> <span class="n">pixel_x</span> <span class="o">*</span> <span class="mf">0.75</span>
        <span class="n">delta_y_arcsec</span> <span class="o">=</span> <span class="n">pixel_y</span> <span class="o">*</span> <span class="mf">0.75</span>

        <span class="c1"># Compute the effective position in the IFU focal plane (arcsec)</span>
        <span class="n">effective_x</span> <span class="o">=</span> <span class="n">fiber_x</span> <span class="o">+</span> <span class="n">delta_x_arcsec</span>
        <span class="n">effective_y</span> <span class="o">=</span> <span class="n">fiber_y</span> <span class="o">+</span> <span class="n">delta_y_arcsec</span>

        <span class="c1"># Convert the effective offset (arcsec) to degrees</span>
        <span class="n">ra_offset_deg</span> <span class="o">=</span> <span class="n">effective_x</span> <span class="o">/</span> <span class="mf">3600.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">))</span>
        <span class="n">dec_offset_deg</span> <span class="o">=</span> <span class="n">effective_y</span> <span class="o">/</span> <span class="mf">3600.0</span>

        <span class="n">ra</span> <span class="o">=</span> <span class="n">ra_ref</span> <span class="o">+</span> <span class="n">ra_offset_deg</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">dec_ref</span> <span class="o">+</span> <span class="n">dec_offset_deg</span>

        <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>

    
<div class="viewcode-block" id="CubeConstructor.map_fiber_to_sky">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.map_fiber_to_sky">[docs]</a>
    <span class="k">def</span> <span class="nf">map_fiber_to_sky</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">benchside</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map fiber center coordinates to sky coordinates.</span>

<span class="sd">        This provides fiber-level sky mapping using proper astrometric calibration</span>
<span class="sd">        with the reference RA/DEC from the primary header. Each fiber represents </span>
<span class="sd">        0.75 arcseconds on the sky.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            benchside (str): Bench and side identifier (e.g., &#39;1A&#39;, &#39;2B&#39;)</span>
<span class="sd">            fiber_num (int): Fiber number</span>
<span class="sd">            reference_coord (tuple, optional): Reference (RA, Dec) in degrees</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (ra, dec) sky coordinates in degrees for fiber center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get fiber coordinates in IFU focal plane coordinates</span>
        <span class="n">fiber_x</span><span class="p">,</span> <span class="n">fiber_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fiber_coordinates</span><span class="p">(</span><span class="n">benchside</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fiber_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">fiber_y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid fiber coordinates for </span><span class="si">{</span><span class="n">benchside</span><span class="si">}</span><span class="s2"> fiber </span><span class="si">{</span><span class="n">fiber_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Apply proper astrometric transformation using reference coordinates</span>
        <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">reference_coord</span>

            <span class="c1"># Check if reference coordinates are valid</span>
            <span class="k">if</span> <span class="n">ra_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dec_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid reference coordinates: </span><span class="si">{</span><span class="n">reference_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Scale the fiber coordinates by 0.75&quot; (the fiber size on sky)</span>
                <span class="c1"># The fiber map coordinates are in unit-less values, so we need to convert</span>
                <span class="c1"># them to actual angular offsets by scaling by 0.75&quot; per fiber</span>
                <span class="n">x_arcsec</span> <span class="o">=</span> <span class="n">fiber_x</span> <span class="o">*</span> <span class="mf">0.75</span>
                <span class="n">y_arcsec</span> <span class="o">=</span> <span class="n">fiber_y</span> <span class="o">*</span> <span class="mf">0.75</span>
                
                <span class="c1"># Convert arcseconds to degrees and apply offset from reference position</span>
                <span class="c1"># Use cos(dec) correction for RA to account for spherical projection</span>
                <span class="n">ra</span> <span class="o">=</span> <span class="n">ra_ref</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_arcsec</span> <span class="o">/</span> <span class="mf">3600.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">))</span>
                <span class="n">dec</span> <span class="o">=</span> <span class="n">dec_ref</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_arcsec</span> <span class="o">/</span> <span class="mf">3600.0</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in sky coordinate conversion: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reference coords: RA=</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">)</span><span class="si">}</span><span class="s2">), DEC=</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fiber coords: X=</span><span class="si">{</span><span class="n">fiber_x</span><span class="si">}</span><span class="s2">, Y=</span><span class="si">{</span><span class="n">fiber_y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback to simple conversion if no reference provided</span>
            <span class="c1"># Still apply the 0.75&quot; scaling</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="p">(</span><span class="n">fiber_x</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="p">(</span><span class="n">fiber_y</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3600.0</span>

        <span class="k">return</span> <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span></div>

    
<div class="viewcode-block" id="CubeConstructor.create_wavelength_grid">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.create_wavelength_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">create_wavelength_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extractions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> 
                              <span class="n">wavelength_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">dispersion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a common wavelength grid for the cube (RSS version).</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            extractions (List[Dict]): List of RSS extraction dictionaries</span>
<span class="sd">            wavelength_range (tuple, optional): (min_wave, max_wave) in Angstroms</span>
<span class="sd">            dispersion (float, optional): Wavelength dispersion in Angstroms/pixel</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Common wavelength grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_wavelengths</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># First check if we have per-fiber wavelength data in &#39;wave&#39;</span>
        <span class="k">for</span> <span class="n">extraction</span> <span class="ow">in</span> <span class="n">extractions</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;wave&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This is the new format with per-fiber wavelength arrays</span>
                <span class="n">all_wavelengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="s1">&#39;wave_common&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave_common&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This is the new format with a common wavelength array</span>
                <span class="n">all_wavelengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave_common&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;wavelength&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wavelength&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># For backward compatibility</span>
                <span class="n">all_wavelengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wavelength&#39;</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_wavelengths</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No wavelength information found in RSS extractions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wavelength_range</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3500.0</span><span class="p">,</span> <span class="mf">9500.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dispersion</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">n_pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">wavelength_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dispersion</span><span class="p">)</span>
            <span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">wavelength_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_pixels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Filter out NaN values</span>
            <span class="n">all_wavelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_wavelengths</span><span class="p">)</span>
            <span class="n">valid_wavelengths</span> <span class="o">=</span> <span class="n">all_wavelengths</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">all_wavelengths</span><span class="p">)]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_wavelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;All wavelength values are NaN&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wavelength_range</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3500.0</span><span class="p">,</span> <span class="mf">9500.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dispersion</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">n_pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">wavelength_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dispersion</span><span class="p">)</span>
                <span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">wavelength_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_pixels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">valid_wavelengths</span><span class="p">)</span>
                <span class="n">max_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">valid_wavelengths</span><span class="p">)</span>
                
                <span class="c1"># Apply user-provided wavelength range if specified</span>
                <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">min_wave</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_wave</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">max_wave</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_wave</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="c1"># Determine dispersion if not provided</span>
                <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dispersions</span> <span class="o">=</span> <span class="p">[]</span>
                    
                    <span class="c1"># Try to compute dispersion from per-fiber wavelength arrays</span>
                    <span class="k">for</span> <span class="n">extraction</span> <span class="ow">in</span> <span class="n">extractions</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s1">&#39;wave&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># Calculate dispersion for each fiber</span>
                            <span class="k">for</span> <span class="n">fiber_wv</span> <span class="ow">in</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]:</span>
                                <span class="c1"># Remove NaNs for calculating diff</span>
                                <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_wv</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Need at least 2 points</span>
                                    <span class="n">valid_wv</span> <span class="o">=</span> <span class="n">fiber_wv</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
                                    <span class="n">wave_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">valid_wv</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">dispersions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">wave_diff</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="s1">&#39;wave_common&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave_common&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># Calculate dispersion from common wavelength array</span>
                            <span class="n">wave_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wave_common&#39;</span><span class="p">])</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">dispersions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">wave_diff</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="s1">&#39;wavelength&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wavelength&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># For backward compatibility</span>
                            <span class="n">wv</span> <span class="o">=</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;wavelength&#39;</span><span class="p">]</span>
                            <span class="n">wave_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wv</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">dispersions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">wave_diff</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    
                    <span class="k">if</span> <span class="n">dispersions</span><span class="p">:</span>
                        <span class="c1"># Take the median of positive dispersion values</span>
                        <span class="n">positive_dispersions</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dispersions</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">positive_dispersions</span><span class="p">:</span>
                            <span class="n">dispersion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">positive_dispersions</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">dispersion</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dispersion</span> <span class="o">=</span> <span class="mf">1.0</span>
                
                <span class="n">n_pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">max_wave</span> <span class="o">-</span> <span class="n">min_wave</span><span class="p">)</span> <span class="o">/</span> <span class="n">dispersion</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Created wavelength grid: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">wavelength_grid</span><span class="p">)</span><span class="si">}</span><span class="s1"> pixels, &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> Å, &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;dispersion: </span><span class="si">{</span><span class="n">dispersion</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> Å/pixel&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wavelength_grid</span></div>


<div class="viewcode-block" id="CubeConstructor.create_spatial_grid">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.create_spatial_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">create_spatial_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extractions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span>
                           <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create spatial grids for the cube based on fiber positions (RSS version).</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            extractions (List[Dict]): List of RSS extraction dictionaries</span>
<span class="sd">            metadata (List[Dict]): Corresponding metadata</span>
<span class="sd">            spatial_sampling (float): Spatial sampling in units (default: 1.0)</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: (x_grid, y_grid) spatial coordinate arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">extraction</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">extractions</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
            <span class="c1"># Check for the new FIBERMAP format first</span>
            <span class="k">if</span> <span class="s1">&#39;fibermap&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;fibermap&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Use FIBER_ID and BENCHSIDE from FIBERMAP</span>
                <span class="n">fibermap</span> <span class="o">=</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;fibermap&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;FIBER_ID&#39;</span> <span class="ow">in</span> <span class="n">fibermap</span> <span class="ow">and</span> <span class="s1">&#39;BENCHSIDE&#39;</span> <span class="ow">in</span> <span class="n">fibermap</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">fiber_id</span><span class="p">,</span> <span class="n">benchside</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">fibermap</span><span class="p">[</span><span class="s1">&#39;FIBER_ID&#39;</span><span class="p">],</span> <span class="n">fibermap</span><span class="p">[</span><span class="s1">&#39;BENCHSIDE&#39;</span><span class="p">])):</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fiber_coordinates</span><span class="p">(</span><span class="n">benchside</span><span class="p">,</span> <span class="n">fiber_id</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">x_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                            <span class="n">y_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="k">continue</span>  <span class="c1"># Skip the old format handling</span>
            
            <span class="c1"># Fallback for backward compatibility</span>
            <span class="n">benchside</span> <span class="o">=</span> <span class="n">extraction</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;benchside&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">benchside</span> <span class="ow">and</span> <span class="s1">&#39;bench&#39;</span> <span class="ow">in</span> <span class="n">extraction</span> <span class="ow">and</span> <span class="s1">&#39;side&#39;</span> <span class="ow">in</span> <span class="n">extraction</span><span class="p">:</span>
                <span class="n">benchside</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;bench&#39;</span><span class="p">]</span><span class="si">}{</span><span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;side&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            
            <span class="n">flux</span> <span class="o">=</span> <span class="n">extraction</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span>
            <span class="n">nfibers</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">flux</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">fiber_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfibers</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fiber_coordinates</span><span class="p">(</span><span class="n">benchside</span><span class="p">,</span> <span class="n">fiber_num</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">x_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">y_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No valid fiber positions found, using default grid&quot;</span><span class="p">)</span>
            <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">46</span><span class="p">)</span>
            <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">43</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_positions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_positions</span><span class="p">)</span>
            <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_positions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_positions</span><span class="p">)</span>
            <span class="n">x_padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
            <span class="n">y_padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
            <span class="n">x_min</span> <span class="o">-=</span> <span class="n">x_padding</span>
            <span class="n">x_max</span> <span class="o">+=</span> <span class="n">x_padding</span>
            <span class="n">y_min</span> <span class="o">-=</span> <span class="n">y_padding</span>
            <span class="n">y_max</span> <span class="o">+=</span> <span class="n">y_padding</span>
            <span class="n">n_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">spatial_sampling</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">n_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">spatial_sampling</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">x_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">n_x</span><span class="p">)</span>
            <span class="n">y_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">n_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Created spatial grids: X=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x_grid</span><span class="p">)</span><span class="si">}</span><span class="s1"> pixels, Y=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">y_grid</span><span class="p">)</span><span class="si">}</span><span class="s1"> pixels&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span></div>


<div class="viewcode-block" id="CubeConstructor.interpolate_spectrum">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.interpolate_spectrum">[docs]</a>
    <span class="k">def</span> <span class="nf">interpolate_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">flux_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                           <span class="n">wavelength_out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a spectrum onto a new wavelength grid.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            wavelength_in (np.ndarray): Input wavelength array</span>
<span class="sd">            flux_in (np.ndarray): Input flux array</span>
<span class="sd">            wavelength_out (np.ndarray): Output wavelength grid</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Interpolated flux array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavelength_in</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux_in</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wavelength and flux arrays must have same length&quot;</span><span class="p">)</span>
        
        <span class="c1"># Remove NaN values</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">wavelength_in</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">flux_in</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">wavelength_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="n">wave_clean</span> <span class="o">=</span> <span class="n">wavelength_in</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
        <span class="n">flux_clean</span> <span class="o">=</span> <span class="n">flux_in</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
        
        <span class="c1"># Sort by wavelength</span>
        <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">wave_clean</span><span class="p">)</span>
        <span class="n">wave_clean</span> <span class="o">=</span> <span class="n">wave_clean</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>
        <span class="n">flux_clean</span> <span class="o">=</span> <span class="n">flux_clean</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>
        
        <span class="c1"># Interpolate</span>
        <span class="n">flux_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">wavelength_out</span><span class="p">,</span> <span class="n">wave_clean</span><span class="p">,</span> <span class="n">flux_clean</span><span class="p">,</span> 
                           <span class="n">left</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">flux_out</span></div>

    
<div class="viewcode-block" id="CubeConstructor.construct_cube_from_rss">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.construct_cube_from_rss">[docs]</a>
    <span class="k">def</span> <span class="nf">construct_cube_from_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rss_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">dispersion</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
                           <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct IFU cubes from an RSS file or a set of channel-specific RSS files.</span>

<span class="sd">        This method can handle two scenarios:</span>
<span class="sd">        1. A single RSS file with all channels included</span>
<span class="sd">        2. Multiple channel-specific RSS files with the naming pattern: </span>
<span class="sd">           {base_name}_extract_RSS_{channel}.fits (e.g., blue, green, red)</span>

<span class="sd">        The method first checks if channel-specific files exist. If found, it processes</span>
<span class="sd">        those files individually. Otherwise, it loads all channels from the single RSS file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            rss_file (str): Path to RSS FITS file or base path to channel-specific files</span>
<span class="sd">            wavelength_range (tuple, optional): Min/max wavelength range</span>
<span class="sd">            dispersion (float): Wavelength dispersion in Angstroms/pixel</span>
<span class="sd">            spatial_sampling (float): Spatial sampling in arcsec/pixel (default: 0.75)</span>
<span class="sd">            reference_coord (tuple, optional): Reference RA/Dec for WCS</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, np.ndarray]: Dictionary of channel cubes {channel: cube_data}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, check if we have channel-specific RSS files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Checking for channel-specific RSS files for: </span><span class="si">{</span><span class="n">rss_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Remove .fits extension if present to get base path</span>
        <span class="n">base_path</span> <span class="o">=</span> <span class="n">rss_file</span>
        <span class="k">if</span> <span class="n">rss_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">):</span>
            <span class="n">base_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">rss_file</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># If it already includes a channel suffix, remove it to get the real base name</span>
            <span class="k">if</span> <span class="s1">&#39;_extract_RSS_&#39;</span> <span class="ow">in</span> <span class="n">base_path</span><span class="p">:</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">base_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_extract_RSS_&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">base_path</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Check if any channel-specific files exist</span>
        <span class="n">channel_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_channel_rss_files</span><span class="p">(</span><span class="n">base_path</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">channel_files</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We found channel-specific files, process them</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> channel-specific RSS files, processing individually&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_cubes_from_multi_channel_rss</span><span class="p">(</span>
                <span class="n">base_path</span><span class="p">,</span>
                <span class="n">wavelength_range</span><span class="o">=</span><span class="n">wavelength_range</span><span class="p">,</span>
                <span class="n">dispersion</span><span class="o">=</span><span class="n">dispersion</span><span class="p">,</span>
                <span class="n">spatial_sampling</span><span class="o">=</span><span class="n">spatial_sampling</span><span class="p">,</span>
                <span class="n">reference_coord</span><span class="o">=</span><span class="n">reference_coord</span>
            <span class="p">)</span>
        
        <span class="c1"># If no channel-specific files found or processing failed, fall back to the original method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No channel-specific RSS files found, processing single file: </span><span class="si">{</span><span class="n">rss_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Load all channels from the RSS file</span>
        <span class="n">channels_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rss_channels</span><span class="p">(</span><span class="n">rss_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channels_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No channels found in RSS file&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found channels in single file: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">channels_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Extract RA and DEC from the primary header</span>
        <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">rss_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdul</span><span class="p">:</span>
            <span class="n">primary_header</span> <span class="o">=</span> <span class="n">hdul</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">ra_ref</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;RA&#39;</span><span class="p">)</span>
            <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;DEC&#39;</span><span class="p">)</span>

            <span class="c1"># Check if RA and DEC are valid</span>
            <span class="k">if</span> <span class="n">ra_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dec_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ra_ref</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dec_ref</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No valid RA/DEC found in primary header, using local coordinates&quot;</span><span class="p">)</span>
                <span class="c1"># Try to use HIERARCH TEL RA/DEC as fallback if available</span>
                <span class="n">tel_ra</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HIERARCH TEL RA&#39;</span><span class="p">)</span>
                <span class="n">tel_dec</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HIERARCH TEL DEC&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">tel_ra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tel_dec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Convert telescope coordinates if they&#39;re in string format</span>
                    <span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="n">SkyCoord</span>
                    <span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">tel_ra</span><span class="p">),</span> <span class="n">dec</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">tel_dec</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
                        <span class="n">ra_ref</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">deg</span>
                        <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">deg</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using telescope coordinates: RA=</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">ref_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to convert telescope coordinates: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Convert to float if they&#39;re strings</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ra_ref</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not convert RA value &#39;</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">&#39; to float&quot;</span><span class="p">)</span>
                        <span class="n">ra_ref</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dec_ref</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not convert DEC value &#39;</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2">&#39; to float&quot;</span><span class="p">)</span>
                        <span class="n">dec_ref</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">ra_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using header reference coordinates: RA=</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Override with provided reference_coord if given</span>
        <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">reference_coord</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using provided reference coordinates: RA=</span><span class="si">{</span><span class="n">ref_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">ref_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize the WCS with the reference coordinates</span>
        <span class="k">if</span> <span class="n">ref_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We&#39;re setting a preliminary WCS here, which will be updated for each channel</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">naxis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">ref_coords</span>

            <span class="c1"># Set the pixel scale based on the 0.75&quot; fiber size on sky</span>
            <span class="n">pixel_scale_deg</span> <span class="o">=</span> <span class="n">spatial_sampling</span> <span class="o">/</span> <span class="mf">3600.0</span>  <span class="c1"># Convert arcsec to degrees</span>

            <span class="c1"># Set up the WCS parameters</span>
            <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span> <span class="o">=</span> <span class="p">[</span><span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>  <span class="c1"># Wavelength will be updated later</span>
            <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cdelt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pixel_scale_deg</span><span class="p">,</span> <span class="n">pixel_scale_deg</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">]</span>  <span class="c1"># Negative for RA per convention</span>
            <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;RA---TAN&#39;</span><span class="p">,</span> <span class="s1">&#39;DEC--TAN&#39;</span><span class="p">,</span> <span class="s1">&#39;WAVE&#39;</span><span class="p">]</span>
            <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cunit</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;Angstrom&#39;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>  <span class="c1"># Store the WCS with proper RA/DEC</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initialized WCS with reference RA=</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2"> and pixel scale=</span><span class="si">{</span><span class="n">spatial_sampling</span><span class="si">}</span><span class="s2"> arcsec&quot;</span><span class="p">)</span>

        <span class="c1"># Construct a cube for each channel</span>
        <span class="n">channel_cubes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">channel_wavelength_grids</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Store wavelength grid for each channel</span>
        <span class="n">channel_wcs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Store WCS for each channel</span>

        <span class="c1"># Save original attributes to restore later</span>
        <span class="n">original_wavelength_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span>
        <span class="n">original_wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        <span class="n">original_cube_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span>

        <span class="c1"># Process each channel</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constructing cube for channel: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Reset wavelength grid for this channel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Construct cube for this channel</span>
            <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_cube_from_rss_channel</span><span class="p">(</span>
                <span class="n">rss_file</span><span class="o">=</span><span class="n">rss_file</span><span class="p">,</span>
                <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span>
                <span class="n">wavelength_range</span><span class="o">=</span><span class="n">wavelength_range</span><span class="p">,</span>
                <span class="n">dispersion</span><span class="o">=</span><span class="n">dispersion</span><span class="p">,</span>
                <span class="n">spatial_sampling</span><span class="o">=</span><span class="n">spatial_sampling</span><span class="p">,</span>
                <span class="n">reference_coord</span><span class="o">=</span><span class="n">ref_coords</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">cube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">channel_cubes</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">cube</span>

                <span class="c1"># Save the wavelength grid that was created for this channel</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">channel_wavelength_grids</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved wavelength grid for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: &quot;</span> 
                                   <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>

                <span class="c1"># Update the WCS for this channel with the proper wavelength grid</span>
                <span class="k">if</span> <span class="n">ref_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">channel_wcs</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_wcs</span><span class="p">(</span><span class="n">ref_coords</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">)</span>

        <span class="c1"># Store the channel-specific data for use when saving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span> <span class="o">=</span> <span class="n">channel_wavelength_grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span> <span class="o">=</span> <span class="n">channel_wcs</span>

        <span class="c1"># Restore original attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">original_wavelength_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">original_wcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="o">=</span> <span class="n">original_cube_data</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_cubes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to construct any channel cubes&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully constructed cubes for channels: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">channel_cubes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">channel_cubes</span></div>


<div class="viewcode-block" id="CubeConstructor.load_rss_channels">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.load_rss_channels">[docs]</a>
    <span class="k">def</span> <span class="nf">load_rss_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rss_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load all channel data from an RSS FITS file in the new format.</span>
<span class="sd">        Returns a dict: {channel: {&#39;flux&#39;:..., &#39;err&#39;:..., &#39;wave&#39;:..., &#39;mask&#39;:..., &#39;fwhm&#39;:..., &#39;fibermap&#39;:...}}</span>
<span class="sd">        </span>
<span class="sd">        New RSS file format:</span>
<span class="sd">        Extension 0 - PRIMARY: primary header only, no data</span>
<span class="sd">        Extension 1 - FLUX: extracted fiber flux in units of 10(-17) erg/s/cm2/Ang/fiber [NWAVE x NFIBER]</span>
<span class="sd">        Extension 2 - ERROR: the error array, sigma of above, for each fiber [NWAVE x NFIBER]</span>
<span class="sd">        Extension 3 - MASK: the pixel mask array for each fiber [NWAVE x NFIBER]</span>
<span class="sd">        Extension 4 - WAVE: the wavelength array for each fiber [NWAVE x NFIBER]</span>
<span class="sd">        Extension 5 - FWHM: the full width half max array for each fiber [NWAVE x NFIBER]</span>
<span class="sd">        Extension 6 - FIBERMAP: the complete fibermap [BINARY FITS TABLE]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading channels from RSS file: </span><span class="si">{</span><span class="n">rss_file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">rss_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdul</span><span class="p">:</span>
            <span class="c1"># First get the channel from the primary header</span>
            <span class="n">primary_hdr</span> <span class="o">=</span> <span class="n">hdul</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">primary_hdr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">,</span> <span class="s1">&#39;UNKNOWN&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            
            <span class="c1"># Initialize the channel dictionary</span>
            <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            
            <span class="c1"># Check if all required extensions are present</span>
            <span class="n">required_extensions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">,</span> <span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="s1">&#39;WAVE&#39;</span><span class="p">,</span> <span class="s1">&#39;FWHM&#39;</span><span class="p">,</span> <span class="s1">&#39;FIBERMAP&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">required_extensions</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ext</span> <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="n">hdul</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required extension </span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2"> not found in RSS file&quot;</span><span class="p">)</span>
            
            <span class="c1"># Process all extensions</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hdul</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">extname</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;FLUX&#39;</span><span class="p">:</span>
                        <span class="c1"># FLUX: [NWAVE x NFIBER] array</span>
                        <span class="n">flux</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded FLUX extension with shape </span><span class="si">{</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose to [NFIBER x NWAVE]</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">:</span>
                        <span class="c1"># ERROR: [NWAVE x NFIBER] array</span>
                        <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded ERROR extension with shape </span><span class="si">{</span><span class="n">error</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose to [NFIBER x NWAVE]</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;MASK&#39;</span><span class="p">:</span>
                        <span class="c1"># MASK: [NWAVE x NFIBER] array</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded MASK extension with shape </span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;dq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose to [NFIBER x NWAVE]</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;WAVE&#39;</span><span class="p">:</span>
                        <span class="c1"># WAVE: [NWAVE x NFIBER] array - now has per-fiber wavelength data</span>
                        <span class="n">wave</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded WAVE extension with shape </span><span class="si">{</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
                        <span class="c1"># Store the per-fiber wavelength array (transpose to [NFIBER x NWAVE])</span>
                        <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wave</span><span class="o">.</span><span class="n">T</span>
                        
                        <span class="c1"># Also compute a common wavelength grid as the median across all fibers</span>
                        <span class="c1"># This is useful for operations that need a single wavelength grid</span>
                        <span class="n">wave_common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Median across fibers for each wavelength point</span>
                        <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;wave_common&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wave_common</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created common wavelength grid with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">wave_common</span><span class="p">)</span><span class="si">}</span><span class="s2"> points&quot;</span><span class="p">)</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;FWHM&#39;</span><span class="p">:</span>
                        <span class="c1"># FWHM: [NWAVE x NFIBER] array</span>
                        <span class="n">fwhm</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded FWHM extension with shape </span><span class="si">{</span><span class="n">fwhm</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhm</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose to [NFIBER x NWAVE]</span>
                        
                    <span class="k">elif</span> <span class="n">extname</span> <span class="o">==</span> <span class="s1">&#39;FIBERMAP&#39;</span><span class="p">:</span>
                        <span class="c1"># FIBERMAP: binary table with fiber information</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="p">):</span>
                            <span class="c1"># Create a table dictionary for fiber metadata</span>
                            <span class="n">table_data</span> <span class="o">=</span> <span class="p">{}</span>
                            <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">hdu</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                <span class="n">col_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                                
                                <span class="c1"># Convert any byte strings to regular strings</span>
                                <span class="k">if</span> <span class="n">col_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                                    <span class="n">col_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span> 
                                                       <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">col_data</span><span class="p">])</span>
                                
                                <span class="n">table_data</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_data</span>
                            
                            <span class="c1"># Make sure we have the required columns</span>
                            <span class="k">if</span> <span class="s1">&#39;FIBER_ID&#39;</span> <span class="ow">in</span> <span class="n">table_data</span><span class="p">:</span>
                                <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table_data</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded FIBERMAP with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">table_data</span><span class="p">[</span><span class="s1">&#39;FIBER_ID&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> entries&quot;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;FIBERMAP is missing required FIBER_ID column&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIBERMAP extension is not a binary table&quot;</span><span class="p">)</span>
                
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading data from </span><span class="si">{</span><span class="n">extname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check if we have all necessary data</span>
            <span class="k">if</span> <span class="s1">&#39;flux&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No FLUX data found for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;wave&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No wavelength data found for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No FIBERMAP data found for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="c1"># Create a default table if needed</span>
                <span class="k">if</span> <span class="s1">&#39;flux&#39;</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
                    <span class="n">n_fibers</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;table&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;FIBER_ID&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_fibers</span><span class="p">),</span>
                        <span class="s1">&#39;BENCHSIDE&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;UNKNOWN&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_fibers</span><span class="p">)</span>
                    <span class="p">}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created default fiber mapping with </span><span class="si">{</span><span class="n">n_fibers</span><span class="si">}</span><span class="s2"> fibers&quot;</span><span class="p">)</span>
            
            <span class="c1"># Map the BENCHSIDE information to the fibers</span>
            <span class="k">if</span> <span class="s1">&#39;table&#39;</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;BENCHSIDE&#39;</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;table&#39;</span><span class="p">]:</span>
                <span class="n">benchsides</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;table&#39;</span><span class="p">][</span><span class="s1">&#39;BENCHSIDE&#39;</span><span class="p">]</span>
                <span class="n">fiber_ids</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;table&#39;</span><span class="p">][</span><span class="s1">&#39;FIBER_ID&#39;</span><span class="p">]</span>
                
                <span class="c1"># Create a simple string mapping format</span>
                <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;benchside_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">fiber_id</span><span class="p">,</span> <span class="n">benchside</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">fiber_ids</span><span class="p">,</span> <span class="n">benchsides</span><span class="p">)):</span>
                    <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;benchside_map&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">fiber_id</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">benchside</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created benchside mapping for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;benchside_map&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> fibers&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No channel data found in RSS file. Check if file format is correct.&quot;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">channels</span></div>


<div class="viewcode-block" id="CubeConstructor.construct_cube_from_rss_channel">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.construct_cube_from_rss_channel">[docs]</a>
    <span class="k">def</span> <span class="nf">construct_cube_from_rss_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rss_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">dispersion</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
                                      <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct IFU cube from a single channel in an RSS FITS file.</span>
<span class="sd">    </span>
<span class="sd">        Each fiber spectrum in the stacked RSS file is placed at its correct spatial position</span>
<span class="sd">        in the output cube, based on the fiber map. Each spaxel has a fixed size of 0.75 arcseconds</span>
<span class="sd">        by default. The wavelength information for each fiber is read directly from the WAVELENGTH</span>
<span class="sd">        column in the binary table, allowing for proper wavelength calibration per fiber.</span>
<span class="sd">    </span>
<span class="sd">        Parameters:</span>
<span class="sd">            rss_file (str): Path to RSS FITS file</span>
<span class="sd">            channel (str): Channel identifier (e.g., &#39;RED&#39;, &#39;GREEN&#39;, &#39;BLUE&#39;)</span>
<span class="sd">            wavelength_range (tuple, optional): Min/max wavelength range</span>
<span class="sd">            dispersion (float): Wavelength dispersion in Angstroms/pixel</span>
<span class="sd">            spatial_sampling (float): Spatial sampling in arcsec/pixel (default: 0.75)</span>
<span class="sd">            reference_coord (tuple, optional): Reference RA/Dec for WCS</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 3D cube data with shape [wavelength, y, x]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Load the channel data from RSS file</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_rss_channels</span><span class="p">(</span><span class="n">rss_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> not found in RSS file.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
    
        <span class="c1"># Get the flux data and table</span>
        <span class="n">flux_data</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span>
        <span class="n">table_data</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;table&#39;</span><span class="p">)</span>
        
        <span class="c1"># Get the wavelength data for each fiber</span>
        <span class="n">fiber_wavelengths</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wave&#39;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">flux_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No flux data found for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
    
        <span class="n">n_fibers</span><span class="p">,</span> <span class="n">n_pixels</span> <span class="o">=</span> <span class="n">flux_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> data shape: </span><span class="si">{</span><span class="n">flux_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">n_fibers</span><span class="si">}</span><span class="s2"> fibers)&quot;</span><span class="p">)</span>
    
        <span class="c1"># Determine the wavelength grid for the cube</span>
        <span class="c1"># Check if we have per-fiber wavelengths</span>
        <span class="k">if</span> <span class="n">fiber_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fiber_wavelengths</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">flux_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using per-fiber wavelength arrays for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">, shape: </span><span class="si">{</span><span class="n">fiber_wavelengths</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># DEBUG: Add diagnostics to understand the wavelength data</span>
            <span class="n">total_wavelength_points</span> <span class="o">=</span> <span class="n">n_fibers</span> <span class="o">*</span> <span class="n">n_pixels</span>
            <span class="n">nan_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_wavelengths</span><span class="p">))</span>
            <span class="n">nan_percentage</span> <span class="o">=</span> <span class="p">(</span><span class="n">nan_count</span> <span class="o">/</span> <span class="n">total_wavelength_points</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wavelength diagnostics: </span><span class="si">{</span><span class="n">nan_count</span><span class="si">}</span><span class="s2"> NaN values out of </span><span class="si">{</span><span class="n">total_wavelength_points</span><span class="si">}</span><span class="s2"> points (</span><span class="si">{</span><span class="n">nan_percentage</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check how many wavelength values are valid per pixel position</span>
            <span class="n">valid_per_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_wavelengths</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">valid_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_per_position</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid wavelength positions: </span><span class="si">{</span><span class="n">valid_positions</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">n_pixels</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="p">(</span><span class="n">valid_positions</span><span class="o">/</span><span class="n">n_pixels</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
            
            <span class="c1"># Show distribution of valid wavelength points</span>
            <span class="n">min_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">valid_per_position</span><span class="p">)</span>
            <span class="n">max_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">valid_per_position</span><span class="p">)</span>
            <span class="n">mean_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">valid_per_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid fibers per wavelength position: min=</span><span class="si">{</span><span class="n">min_valid</span><span class="si">}</span><span class="s2">, max=</span><span class="si">{</span><span class="n">max_valid</span><span class="si">}</span><span class="s2">, mean=</span><span class="si">{</span><span class="n">mean_valid</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># For the new RSS structure, wavelength is now stored per-fiber in WAVE extension</span>
            <span class="c1"># We need to create a common wavelength grid for the cube</span>
            <span class="n">extractions</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">fiber_wavelengths</span><span class="p">}]</span>
            
            <span class="c1"># Create a common wavelength grid using the existing method</span>
            <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_wavelength_grid</span><span class="p">(</span><span class="n">extractions</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created wavelength grid with user parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate median wavelength grid from all fibers (removing NaN values)</span>
                <span class="c1"># First, find valid wavelength arrays (non-NaN)</span>
                <span class="n">valid_wavelengths</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_fibers</span><span class="p">):</span>
                    <span class="n">wave</span> <span class="o">=</span> <span class="n">fiber_wavelengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">wave</span><span class="p">)):</span>
                        <span class="n">valid_wavelengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">valid_wavelengths</span><span class="p">:</span>
                    <span class="c1"># If we have valid wavelength arrays, use the median</span>
                    <span class="n">valid_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">valid_wavelengths</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">valid_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created median wavelength grid from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_wavelengths</span><span class="p">)</span><span class="si">}</span><span class="s2"> valid fiber wavelengths: &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If no valid wavelength arrays, use a default grid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No valid wavelength arrays found. Using default wavelength grid.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_wavelength_grid</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check if we have a common wavelength grid in the &#39;wave_common&#39; key</span>
            <span class="k">if</span> <span class="s1">&#39;wave_common&#39;</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="ow">and</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;wave_common&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wave_common</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="s1">&#39;wave_common&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_common</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_pixels</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">wave_common</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using common wavelength grid from RSS file: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Common wavelength grid length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">wave_common</span><span class="p">)</span><span class="si">}</span><span class="s2"> doesn&#39;t match flux shape </span><span class="si">{</span><span class="n">n_pixels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_wavelength_grid</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fall back to default grid if per-fiber wavelengths aren&#39;t available</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No wavelength data found. Using default wavelength grid.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_wavelength_grid</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">)</span>
    
        <span class="c1"># Get spatial coordinates for all fibers</span>
        <span class="n">fiber_positions</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="k">if</span> <span class="n">table_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use table data to get fiber information</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_fibers</span><span class="p">):</span>
                <span class="c1"># Get benchside and fiber number</span>
                <span class="n">benchside</span> <span class="o">=</span> <span class="n">table_data</span><span class="p">[</span><span class="s1">&#39;BENCHSIDE&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">fiber_id</span> <span class="o">=</span> <span class="n">table_data</span><span class="p">[</span><span class="s1">&#39;FIBER_ID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
    
                <span class="c1"># Get physical fiber coordinates in the IFU focal plane</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fiber_coordinates</span><span class="p">(</span><span class="n">benchside</span><span class="p">,</span> <span class="n">fiber_id</span><span class="p">)</span>
    
                <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Apply the 0.75&quot; scale to convert from fiber map units to arcseconds</span>
                    <span class="n">x_arcsec</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.75</span>
                    <span class="n">y_arcsec</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="mf">0.75</span>
    
                    <span class="c1"># Convert to sky coordinates if reference coordinate is provided</span>
                    <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">reference_coord</span>
    
                        <span class="c1"># Convert arcsec offsets to degrees and apply spherical projection correction</span>
                        <span class="n">ra</span> <span class="o">=</span> <span class="n">ra_ref</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_arcsec</span> <span class="o">/</span> <span class="mf">3600.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">))</span>
                        <span class="n">dec</span> <span class="o">=</span> <span class="n">dec_ref</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_arcsec</span> <span class="o">/</span> <span class="mf">3600.0</span><span class="p">)</span>
    
                        <span class="c1"># Convert back to angular offset from reference for spatial grid</span>
                        <span class="n">x_sky</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra</span> <span class="o">-</span> <span class="n">ra_ref</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3600.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">))</span>
                        <span class="n">y_sky</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec</span> <span class="o">-</span> <span class="n">dec_ref</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3600.0</span>
    
                        <span class="n">fiber_positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">x_sky</span><span class="p">,</span> <span class="n">y_sky</span><span class="p">))</span>
    
                        <span class="c1"># Debug information for the first few fibers</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fiber </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: benchside=</span><span class="si">{</span><span class="n">benchside</span><span class="si">}</span><span class="s2">, fiber_id=</span><span class="si">{</span><span class="n">fiber_id</span><span class="si">}</span><span class="s2">, &quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;x=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">, x_arcsec=</span><span class="si">{</span><span class="n">x_arcsec</span><span class="si">}</span><span class="s2">, y_arcsec=</span><span class="si">{</span><span class="n">y_arcsec</span><span class="si">}</span><span class="s2">, &quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;ra=</span><span class="si">{</span><span class="n">ra</span><span class="si">}</span><span class="s2">, dec=</span><span class="si">{</span><span class="n">dec</span><span class="si">}</span><span class="s2">, x_sky=</span><span class="si">{</span><span class="n">x_sky</span><span class="si">}</span><span class="s2">, y_sky=</span><span class="si">{</span><span class="n">y_sky</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># No reference coordinates, just use the arcsecond values directly</span>
                        <span class="n">fiber_positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">x_arcsec</span><span class="p">,</span> <span class="n">y_arcsec</span><span class="p">))</span>
    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fiber_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No valid fiber positions found for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
    
        <span class="c1"># Continue with rest of the method as before...</span>
        <span class="c1"># Determine spatial extent from fiber positions</span>
        <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">fiber_positions</span><span class="p">]</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">fiber_positions</span><span class="p">]</span>
    
        <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)</span>
        <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_coords</span><span class="p">)</span>
    
        <span class="c1"># Add buffer around edges</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="n">spatial_sampling</span>
        <span class="n">x_min</span> <span class="o">-=</span> <span class="n">buffer</span>
        <span class="n">x_max</span> <span class="o">+=</span> <span class="n">buffer</span>
        <span class="n">y_min</span> <span class="o">-=</span> <span class="n">buffer</span>
        <span class="n">y_max</span> <span class="o">+=</span> <span class="n">buffer</span>
    
        <span class="c1"># Create spatial grid with fixed spaxel size (spatial_sampling is in arcsec/pixel)</span>
        <span class="n">n_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">spatial_sampling</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">n_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">spatial_sampling</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">n_x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">n_y</span><span class="p">)</span>
    
        <span class="c1"># Initialize cube with NaNs</span>
        <span class="n">cube_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">cube_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initialized cube for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> with shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
        <span class="c1"># Create a proper WCS for this cube with the RA/DEC reference and proper spatial scale</span>
        <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_wcs</span><span class="p">(</span><span class="n">reference_coord</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">wcs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created WCS for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> with reference RA=</span><span class="si">{</span><span class="n">reference_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;DEC=</span><span class="si">{</span><span class="n">reference_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, pixel scale=</span><span class="si">{</span><span class="n">spatial_sampling</span><span class="si">}</span><span class="s2"> arcsec&quot;</span><span class="p">)</span>
    
        <span class="c1"># Process each wavelength slice separately for spatial interpolation</span>
        <span class="n">n_wavelength_slices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing all </span><span class="si">{</span><span class="n">n_wavelength_slices</span><span class="si">}</span><span class="s2"> wavelength slices&quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">w_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_wavelength_slices</span><span class="p">):</span>
            <span class="c1"># Extract data for this wavelength from all fibers</span>
            <span class="n">fiber_x</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fiber_y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fiber_values</span> <span class="o">=</span> <span class="p">[]</span>
    
            <span class="c1"># Target wavelength for this slice</span>
            <span class="n">target_wavelength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="n">w_idx</span><span class="p">]</span>
    
            <span class="c1"># Collect valid data points for this wavelength</span>
            <span class="k">for</span> <span class="n">fiber_idx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">fiber_positions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fiber_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fiber_wavelengths</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">flux_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="c1"># Use per-fiber wavelength calibration (from the new RSS format)</span>
                    <span class="c1"># Get this fiber&#39;s wavelength and flux arrays</span>
                    <span class="n">fiber_wave</span> <span class="o">=</span> <span class="n">fiber_wavelengths</span><span class="p">[</span><span class="n">fiber_idx</span><span class="p">]</span>
                    <span class="n">fiber_flux</span> <span class="o">=</span> <span class="n">flux_data</span><span class="p">[</span><span class="n">fiber_idx</span><span class="p">]</span>
                    
                    <span class="c1"># Skip fibers with all NaN wavelengths</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_wave</span><span class="p">)):</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Find valid (non-NaN) wavelength points for this fiber</span>
                    <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_wave</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_flux</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">):</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Get valid wavelengths and flux values</span>
                    <span class="n">valid_wave</span> <span class="o">=</span> <span class="n">fiber_wave</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
                    <span class="n">valid_flux</span> <span class="o">=</span> <span class="n">fiber_flux</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
                    
                    <span class="c1"># Check if the target wavelength is within range of this fiber&#39;s valid wavelengths</span>
                    <span class="n">wave_min</span><span class="p">,</span> <span class="n">wave_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">valid_wave</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">valid_wave</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">wave_min</span> <span class="o">&lt;=</span> <span class="n">target_wavelength</span> <span class="o">&lt;=</span> <span class="n">wave_max</span><span class="p">):</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Interpolate to get the flux at the target wavelength</span>
                    <span class="c1"># Use a try-except block to handle interpolation errors</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">target_wavelength</span><span class="p">,</span> <span class="n">valid_wave</span><span class="p">,</span> <span class="n">valid_flux</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Interpolation error for fiber </span><span class="si">{</span><span class="n">fiber_idx</span><span class="si">}</span><span class="s2"> at wavelength </span><span class="si">{</span><span class="n">target_wavelength</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Use index directly if no per-fiber wavelengths (old format fallback)</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">flux_data</span><span class="p">[</span><span class="n">fiber_idx</span><span class="p">,</span> <span class="n">w_idx</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># Only use finite values</span>
                    <span class="n">fiber_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">fiber_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">fiber_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    
            <span class="c1"># Skip empty slices</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fiber_values</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># Create grid for interpolation</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">)</span>
    
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Limit the number of points to interpolate for very large grids</span>
                <span class="n">max_grid_points</span> <span class="o">=</span> <span class="mi">1000000</span>  <span class="c1"># 1 million points</span>
                <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">max_grid_points</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grid size (</span><span class="si">{</span><span class="n">xi</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> points) exceeds threshold. Downsampling for interpolation.&quot;</span><span class="p">)</span>
                    <span class="c1"># Downsample the grid</span>
                    <span class="n">downsample_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">max_grid_points</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">xi_ds</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[::</span><span class="n">downsample_factor</span><span class="p">,</span> <span class="p">::</span><span class="n">downsample_factor</span><span class="p">]</span>
                    <span class="n">yi_ds</span> <span class="o">=</span> <span class="n">yi</span><span class="p">[::</span><span class="n">downsample_factor</span><span class="p">,</span> <span class="p">::</span><span class="n">downsample_factor</span><span class="p">]</span>
                    
                    <span class="c1"># Perform interpolation on downsampled grid</span>
                    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
                    <span class="n">grid_z_ds</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">fiber_x</span><span class="p">,</span> <span class="n">fiber_y</span><span class="p">),</span>     <span class="c1"># Points where we know values</span>
                        <span class="n">fiber_values</span><span class="p">,</span>           <span class="c1"># Known values</span>
                        <span class="p">(</span><span class="n">xi_ds</span><span class="p">,</span> <span class="n">yi_ds</span><span class="p">),</span>         <span class="c1"># Downsampled points to interpolate</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>       <span class="c1"># Use nearest neighbor interpolation</span>
                        <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span>            <span class="c1"># Rescale to avoid precision issues</span>
                    <span class="p">)</span>
                    
                    <span class="c1"># Upsample back to full grid using nearest neighbor</span>
                    <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">zoom</span>
                    <span class="n">grid_z</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">grid_z_ds</span><span class="p">,</span> <span class="n">downsample_factor</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># order=0 for nearest neighbor</span>
                    
                    <span class="c1"># Ensure the shape matches our original grid</span>
                    <span class="k">if</span> <span class="n">grid_z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upsampled grid shape </span><span class="si">{</span><span class="n">grid_z</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> doesn&#39;t match target shape </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">),</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">))</span><span class="si">}</span><span class="s2">. Using fallback.&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Grid shape mismatch&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Perform interpolation (using nearest neighbor to preserve data values)</span>
                    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
                    <span class="n">grid_z</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">fiber_x</span><span class="p">,</span> <span class="n">fiber_y</span><span class="p">),</span>     <span class="c1"># Points where we know values</span>
                        <span class="n">fiber_values</span><span class="p">,</span>           <span class="c1"># Known values</span>
                        <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span>               <span class="c1"># Points to interpolate</span>
                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>       <span class="c1"># Use nearest neighbor interpolation</span>
                        <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span>            <span class="c1"># Rescale to avoid precision issues</span>
                    <span class="p">)</span>
    
                <span class="c1"># Put interpolated data into cube</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">[</span><span class="n">w_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid_z</span>
                
                <span class="c1"># Process all wavelength slices without time limit</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Interpolation failed for wavelength </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="n">w_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Fall back to nearest grid point method for this slice</span>
                <span class="k">for</span> <span class="n">fiber_idx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">fiber_positions</span><span class="p">:</span>
                    <span class="c1"># Find the closest grid points</span>
                    <span class="n">x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>

                    <span class="c1"># Find the value based on per-fiber wavelength or fixed index</span>
                    <span class="k">if</span> <span class="n">fiber_wavelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fiber_wavelengths</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">flux_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="n">fiber_wave</span> <span class="o">=</span> <span class="n">fiber_wavelengths</span><span class="p">[</span><span class="n">fiber_idx</span><span class="p">]</span>
                        
                        <span class="c1"># Skip fibers with NaN wavelengths</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fiber_wave</span><span class="p">)):</span>
                            <span class="k">continue</span>
                        
                        <span class="n">closest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fiber_wave</span> <span class="o">-</span> <span class="n">target_wavelength</span><span class="p">))</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">flux_data</span><span class="p">[</span><span class="n">fiber_idx</span><span class="p">,</span> <span class="n">closest_idx</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">flux_data</span><span class="p">[</span><span class="n">fiber_idx</span><span class="p">,</span> <span class="n">w_idx</span><span class="p">]</span>

                    <span class="c1"># Place the spectrum point in the cube</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">[</span><span class="n">w_idx</span><span class="p">,</span> <span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cube for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> constructed successfully with spatial interpolation&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span></div>

        
    <span class="k">def</span> <span class="nf">_create_default_wavelength_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a default wavelength grid for a channel when wavelength information is not available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            channel (str): Channel identifier</span>
<span class="sd">            n_pixels (int): Number of pixels in the wavelength dimension</span>
<span class="sd">            wavelength_range (tuple, optional): User-provided wavelength range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use the manually provided range</span>
            <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="n">wavelength_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Infer reasonable wavelength range based on channel</span>
            <span class="n">channel_upper</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">channel_upper</span> <span class="o">==</span> <span class="s2">&quot;RED&quot;</span><span class="p">:</span>
                <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="mf">6300.0</span><span class="p">,</span> <span class="mf">9000.0</span>
            <span class="k">elif</span> <span class="n">channel_upper</span> <span class="o">==</span> <span class="s2">&quot;GREEN&quot;</span><span class="p">:</span>
                <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="mf">4800.0</span><span class="p">,</span> <span class="mf">6600.0</span>
            <span class="k">elif</span> <span class="n">channel_upper</span> <span class="o">==</span> <span class="s2">&quot;BLUE&quot;</span><span class="p">:</span>
                <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="mf">3700.0</span><span class="p">,</span> <span class="mf">5100.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default for unknown channels</span>
                <span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span> <span class="o">=</span> <span class="mf">3700.0</span><span class="p">,</span> <span class="mf">9000.0</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_wave</span><span class="p">,</span> <span class="n">max_wave</span><span class="p">,</span> <span class="n">n_pixels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Created default wavelength grid for </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> channel: </span><span class="si">{</span><span class="n">min_wave</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">max_wave</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="CubeConstructor.save_cube">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.save_cube">[docs]</a>
    <span class="k">def</span> <span class="nf">save_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">header_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the reconstructed cube to a FITS file.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            output_path (str): Output file path</span>
<span class="sd">            reference_coord (tuple, optional): (RA, Dec) reference coordinates</span>
<span class="sd">            header_info (dict, optional): Additional header information</span>
<span class="sd">            spatial_sampling (float): Spatial sampling in arcsec/pixel</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            str: Path to saved file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No cube data to save. Run construct_cube() first.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Saving cube to </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># Create WCS</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_wcs</span><span class="p">(</span><span class="n">reference_coord</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">)</span>
        
        <span class="c1"># Create primary HDU</span>
        <span class="n">primary_hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        
        <span class="c1"># Add WCS to header</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">wcs</span><span class="o">.</span><span class="n">to_header</span><span class="p">())</span>
        
        <span class="c1"># Add additional header information</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BUNIT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;counts&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ORIGIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LLAMAS Cube Constructor&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;DATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">)</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">)</span> 
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">)</span>
        
        <span class="c1"># Add detailed wavelength calibration to primary header</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CDELT3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CTYPE3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;WAVE&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CUNIT3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Angstrom&#39;</span>
        
        <span class="c1"># Add spaxel information</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SPAXELSC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spatial_sampling</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;LLAMAS IFU Data Cube [wavelength, y, x]&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Spaxel size: </span><span class="si">{</span><span class="n">spatial_sampling</span><span class="si">}</span><span class="s1"> arcsec&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Each slice can be summed to create whitelight image&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Each spaxel contains a full spectrum&#39;</span>
        <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Wavelength range: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> Angstroms&#39;</span>
        
        <span class="k">if</span> <span class="n">header_info</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">header_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">primary_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        
        <span class="c1"># Create HDU list and save</span>
        <span class="n">hdul</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">primary_hdu</span><span class="p">])</span>
        
        <span class="c1"># Add wavelength extension</span>
        <span class="n">wave_hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;WAVELENGTH&#39;</span><span class="p">)</span>
        <span class="n">wave_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;WAVELENGTH&#39;</span>
        <span class="n">wave_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BUNIT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Angstrom&#39;</span>
        <span class="n">wave_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Wavelength array for cube&#39;</span>
        <span class="n">hdul</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wave_hdu</span><span class="p">)</span>
        
        <span class="c1"># Add spatial coordinate extensions</span>
        <span class="n">x_hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;XCOORD&#39;</span><span class="p">)</span>
        <span class="n">x_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;XCOORD&#39;</span>
        <span class="n">x_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BUNIT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;arcsec&#39;</span>
        <span class="n">hdul</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_hdu</span><span class="p">)</span>
        
        <span class="n">y_hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;YCOORD&#39;</span><span class="p">)</span>
        <span class="n">y_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;YCOORD&#39;</span>
        <span class="n">y_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BUNIT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;arcsec&#39;</span>
        <span class="n">hdul</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_hdu</span><span class="p">)</span>
        
        <span class="c1"># Save to file</span>
        <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">OUTPUT_DIR</span><span class="p">,</span> <span class="n">output_path</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span> <span class="k">else</span> <span class="n">output_path</span>
        <span class="n">hdul</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cube saved successfully to </span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full_path</span></div>

    
<div class="viewcode-block" id="CubeConstructor.extract_spectrum">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.extract_spectrum">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">aperture_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a spectrum at a given spatial position.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            x (float): X coordinate</span>
<span class="sd">            y (float): Y coordinate  </span>
<span class="sd">            aperture_radius (float): Aperture radius for extraction</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: (wavelength, flux) arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No cube data available. Run construct_cube() first.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Find spatial indices within aperture</span>
        <span class="n">x_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">aperture_radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">aperture_radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No data found at position (</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        
        <span class="c1"># Extract and sum spectra within aperture</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">y_indices</span><span class="p">,</span> <span class="n">x_indices</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">,</span> <span class="n">spectrum</span></div>

    
<div class="viewcode-block" id="CubeConstructor.create_white_light_image">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.create_white_light_image">[docs]</a>
    <span class="k">def</span> <span class="nf">create_white_light_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a white light image by collapsing the spectral dimension.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            wavelength_range (tuple, optional): (min_wave, max_wave) for integration</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 2D white light image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No cube data available. Run construct_cube() first.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wave_mask</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">&gt;=</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">&lt;=</span> <span class="n">wavelength_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">cube_subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">[</span><span class="n">wave_mask</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cube_subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span>
        
        <span class="n">white_light</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">cube_subset</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">white_light</span></div>

    
<div class="viewcode-block" id="CubeConstructor.plot_spectrum">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.plot_spectrum">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">aperture_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> 
                     <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot an extracted spectrum.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            x (float): X coordinate</span>
<span class="sd">            y (float): Y coordinate</span>
<span class="sd">            aperture_radius (float): Aperture radius for extraction</span>
<span class="sd">            save_path (str, optional): Path to save the plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wavelength</span><span class="p">,</span> <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">aperture_radius</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wavelength</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelength (Å)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Flux (counts)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Extracted Spectrum at (</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">y</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum plot saved to </span><span class="si">{</span><span class="n">save_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="CubeConstructor.get_cube_info">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.get_cube_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cube_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get information about the constructed cube.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary containing cube information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;No cube data available&quot;</span><span class="p">}</span>
        
        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cube_shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="s2">&quot;wavelength_range&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="s2">&quot;wavelength_dispersion&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;spatial_range_x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="s2">&quot;spatial_range_y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="s2">&quot;spatial_sampling&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;total_pixels&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;valid_pixels&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">)),</span>
            <span class="s2">&quot;data_range&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span><span class="p">))</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">info</span></div>

    
<div class="viewcode-block" id="CubeConstructor.save_channel_cubes">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.save_channel_cubes">[docs]</a>
    <span class="k">def</span> <span class="nf">save_channel_cubes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_cubes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">output_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                         <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">header_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save multiple channel cubes to FITS files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_cubes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No channel cubes to save.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Store original values to restore at the end</span>
        <span class="n">original_cube_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span>
        <span class="n">original_wavelength_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span>
        <span class="n">original_wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        
        <span class="c1"># Now save each channel with its specific wavelength grid and WCS</span>
        <span class="n">saved_paths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">channel</span><span class="p">,</span> <span class="n">cube_data</span> <span class="ow">in</span> <span class="n">channel_cubes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Set channel-specific values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="o">=</span> <span class="n">cube_data</span>
            
            <span class="c1"># Use the channel-specific wavelength grid and WCS that were stored during construction</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;channel_wavelength_grids&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using stored wavelength grid for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;channel_wcs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create a new WCS if needed</span>
                <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_wcs</span><span class="p">(</span><span class="n">reference_coord</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">)</span>
            
            <span class="c1"># Get and log cube information</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cube information for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="n">cube_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cube_info</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cube_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Create output path with channel name</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">.fits&quot;</span>
            
            <span class="c1"># Add channel info to header</span>
            <span class="n">channel_header</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">header_info</span><span class="p">:</span>
                <span class="n">channel_header</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">header_info</span><span class="p">)</span>
            <span class="n">channel_header</span><span class="p">[</span><span class="s1">&#39;CHANNEL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
            
            <span class="c1"># Save the cube</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_cube</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">reference_coord</span><span class="p">,</span> <span class="n">channel_header</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">)</span>
            <span class="n">saved_paths</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_path</span>
        
        <span class="c1"># Restore original values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="o">=</span> <span class="n">original_cube_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">original_wavelength_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">original_wcs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_paths</span><span class="p">)</span><span class="si">}</span><span class="s2"> channel cubes with prefix: </span><span class="si">{</span><span class="n">output_prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">saved_paths</span></div>

    
<div class="viewcode-block" id="CubeConstructor.create_wcs">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.create_wcs">[docs]</a>
    <span class="k">def</span> <span class="nf">create_wcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WCS</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a World Coordinate System for the cube based on the RSS file&#39;s RA/DEC</span>
<span class="sd">        and the 0.75&quot; fiber scale.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            reference_coord (tuple, optional): (RA, Dec) reference coordinates in degrees</span>
<span class="sd">            spatial_sampling (float): Spatial sampling in arcsec/pixel (default: 0.75)</span>

<span class="sd">        Returns:</span>
<span class="sd">            WCS: World coordinate system object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">naxis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Use provided reference coordinates or defaults</span>
        <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">reference_coord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default to (0, 0) if no reference coordinates provided</span>
            <span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No reference coordinates provided for WCS, using (0, 0)&quot;</span><span class="p">)</span>

        <span class="c1"># Reference pixel at the center of the cube</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">crpix1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_x</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">crpix2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_grid_y</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crpix1</span><span class="p">,</span> <span class="n">crpix2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No spatial grid defined for WCS, using (0, 0) for reference pixel&quot;</span><span class="p">)</span>

        <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crpix</span> <span class="o">=</span> <span class="p">[</span><span class="n">crpix1</span><span class="p">,</span> <span class="n">crpix2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Pixel scale in degrees/pixel based on 0.75&quot; fiber scale</span>
        <span class="c1"># spatial_sampling is in arcsec/pixel</span>
        <span class="n">pixel_scale_deg</span> <span class="o">=</span> <span class="n">spatial_sampling</span> <span class="o">/</span> <span class="mf">3600.0</span>

        <span class="c1"># Set wavelength dispersion if available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wave_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wave_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wave_start</span> <span class="o">=</span> <span class="mf">5000.0</span>
            <span class="n">wave_step</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No wavelength grid defined for WCS, using default values&quot;</span><span class="p">)</span>

        <span class="c1"># Set WCS parameters</span>
        <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">crval</span> <span class="o">=</span> <span class="p">[</span><span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span><span class="p">,</span> <span class="n">wave_start</span><span class="p">]</span>
        <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cdelt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pixel_scale_deg</span><span class="p">,</span> <span class="n">pixel_scale_deg</span><span class="p">,</span> <span class="n">wave_step</span><span class="p">]</span>  <span class="c1"># Negative for RA per convention</span>
        <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;RA---TAN&#39;</span><span class="p">,</span> <span class="s1">&#39;DEC--TAN&#39;</span><span class="p">,</span> <span class="s1">&#39;WAVE&#39;</span><span class="p">]</span>
        <span class="n">wcs</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">cunit</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;Angstrom&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">wcs</span></div>

    
<div class="viewcode-block" id="CubeConstructor.find_channel_rss_files">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.find_channel_rss_files">[docs]</a>
    <span class="k">def</span> <span class="nf">find_channel_rss_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all channel-specific RSS files for a given base path.</span>
<span class="sd">        </span>
<span class="sd">        This method searches for RSS files with channel-specific suffixes like</span>
<span class="sd">        &#39;_extract_RSS_blue.fits&#39;, &#39;_extract_RSS_green.fits&#39;, &#39;_extract_RSS_red.fits&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            base_path (str): Base path/prefix to the RSS files or a single RSS file</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, str]: Dictionary mapping channel names to file paths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Looking for channel-specific RSS files using base path: </span><span class="si">{</span><span class="n">base_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Handle case where base_path is a single RSS file</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">base_path</span><span class="p">)</span>
        <span class="n">base_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">base_path</span><span class="p">)</span>
        
        <span class="c1"># If it&#39;s a full path to a file (with .fits extension)</span>
        <span class="k">if</span> <span class="n">base_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.fits&#39;</span><span class="p">):</span>
            <span class="c1"># Extract base name without extension</span>
            <span class="n">base_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">base_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Check if it&#39;s already a channel-specific file</span>
            <span class="k">if</span> <span class="s1">&#39;_extract_RSS_&#39;</span> <span class="ow">in</span> <span class="n">base_name</span><span class="p">:</span>
                <span class="c1"># Extract the channel from the filename</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">base_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_extract_RSS_&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">]:</span>
                    <span class="n">channel</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># Just return this file with its detected channel</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input is already a channel-specific file for channel: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">{</span><span class="n">channel</span><span class="p">:</span> <span class="n">base_path</span><span class="p">}</span>
                
                <span class="c1"># Get the base name without channel suffix</span>
                <span class="n">base_name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Construct the base path without extension</span>
        <span class="n">base_path_no_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">base_name</span><span class="p">)</span>
        
        <span class="c1"># Dictionary to store found channel files</span>
        <span class="n">channel_files</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Define common channel names</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">]</span>
        
        <span class="c1"># Check for existence of each channel file</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">channel_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_path_no_ext</span><span class="si">}</span><span class="s2">_extract_RSS_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">.fits&quot;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">channel_path</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> channel RSS file: </span><span class="si">{</span><span class="n">channel_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">channel_files</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_path</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_files</span><span class="p">:</span>
            <span class="c1"># If no channel-specific files found, check if the original file exists</span>
            <span class="n">original_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_path_no_ext</span><span class="si">}</span><span class="s2">.fits&quot;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">original_path</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No channel-specific RSS files found, using original file: </span><span class="si">{</span><span class="n">original_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># We&#39;ll return this as an &quot;unknown&quot; channel for compatibility</span>
                <span class="n">channel_files</span><span class="p">[</span><span class="s1">&#39;unknown&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No RSS files found for base path: </span><span class="si">{</span><span class="n">base_path_no_ext</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="c1"># Last resort: if the input is a valid file, use it directly</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">base_path</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using input file directly: </span><span class="si">{</span><span class="n">base_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>  <span class="c1"># Default channel name</span>
                    <span class="c1"># Try to detect channel from filename if possible</span>
                    <span class="k">if</span> <span class="s1">&#39;blue&#39;</span> <span class="ow">in</span> <span class="n">base_path</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                        <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
                    <span class="k">elif</span> <span class="s1">&#39;green&#39;</span> <span class="ow">in</span> <span class="n">base_path</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                        <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
                    <span class="k">elif</span> <span class="s1">&#39;red&#39;</span> <span class="ow">in</span> <span class="n">base_path</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                        <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
                    <span class="n">channel_files</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_path</span>
        
        <span class="k">return</span> <span class="n">channel_files</span></div>

    
<div class="viewcode-block" id="CubeConstructor.construct_cubes_from_multi_channel_rss">
<a class="viewcode-back" href="../../../llamas_pyjamas.Cube.html#llamas_pyjamas.Cube.cubeConstruct.CubeConstructor.construct_cubes_from_multi_channel_rss">[docs]</a>
    <span class="k">def</span> <span class="nf">construct_cubes_from_multi_channel_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rss_base_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                                       <span class="n">wavelength_range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="n">dispersion</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
                                       <span class="n">reference_coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically detect and construct IFU cubes from all channel-specific RSS files.</span>
<span class="sd">        </span>
<span class="sd">        This method finds all channel-specific RSS files (blue, green, red) for a given base path</span>
<span class="sd">        and constructs a cube for each channel. Each channel file is expected to have the format:</span>
<span class="sd">        {base_path}_extract_RSS_{channel}.fits</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            rss_base_path (str): Base path to RSS files or a single RSS file path</span>
<span class="sd">            wavelength_range (tuple, optional): Min/max wavelength range</span>
<span class="sd">            dispersion (float): Wavelength dispersion in Angstroms/pixel</span>
<span class="sd">            spatial_sampling (float): Spatial sampling in arcsec/pixel (default: 0.75)</span>
<span class="sd">            reference_coord (tuple, optional): Reference RA/Dec for WCS</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, np.ndarray]: Dictionary of channel cubes {channel: cube_data}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find all channel-specific RSS files</span>
        <span class="n">channel_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_channel_rss_files</span><span class="p">(</span><span class="n">rss_base_path</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_files</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No RSS files found for base path: </span><span class="si">{</span><span class="n">rss_base_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> channel RSS files&quot;</span><span class="p">)</span>
        
        <span class="c1"># Process each channel file</span>
        <span class="n">channel_cubes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">reference_coords_map</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Process each channel file to extract reference coordinates first</span>
        <span class="k">for</span> <span class="n">channel</span><span class="p">,</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="n">channel_files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Extract RA and DEC from the primary header</span>
            <span class="k">with</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdul</span><span class="p">:</span>
                <span class="n">primary_header</span> <span class="o">=</span> <span class="n">hdul</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
                <span class="n">ra_ref</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;RA&#39;</span><span class="p">)</span>
                <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;DEC&#39;</span><span class="p">)</span>
                
                <span class="c1"># Check if RA and DEC are valid</span>
                <span class="k">if</span> <span class="n">ra_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dec_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ra_ref</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dec_ref</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                    <span class="c1"># Try to use HIERARCH TEL RA/DEC as fallback if available</span>
                    <span class="n">tel_ra</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HIERARCH TEL RA&#39;</span><span class="p">)</span>
                    <span class="n">tel_dec</span> <span class="o">=</span> <span class="n">primary_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HIERARCH TEL DEC&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">tel_ra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tel_dec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Convert telescope coordinates if they&#39;re in string format</span>
                        <span class="kn">from</span> <span class="nn">astropy.coordinates</span> <span class="kn">import</span> <span class="n">SkyCoord</span>
                        <span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">SkyCoord</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">tel_ra</span><span class="p">),</span> <span class="n">dec</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">tel_dec</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">))</span>
                            <span class="n">ra_ref</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">deg</span>
                            <span class="n">dec_ref</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">deg</span>
                            <span class="n">reference_coords_map</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: Using telescope coordinates: RA=</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: Failed to convert telescope coordinates: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">reference_coords_map</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reference_coords_map</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Convert to float if they&#39;re strings</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ra_ref</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ra_ref</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: Could not convert RA value &#39;</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">&#39; to float&quot;</span><span class="p">)</span>
                            <span class="n">ra_ref</span> <span class="o">=</span> <span class="kc">None</span>
                    
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dec_ref</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dec_ref</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: Could not convert DEC value &#39;</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2">&#39; to float&quot;</span><span class="p">)</span>
                            <span class="n">dec_ref</span> <span class="o">=</span> <span class="kc">None</span>
                    
                    <span class="k">if</span> <span class="n">ra_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">reference_coords_map</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_ref</span><span class="p">,</span> <span class="n">dec_ref</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: Using header reference coordinates: RA=</span><span class="si">{</span><span class="n">ra_ref</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">dec_ref</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reference_coords_map</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Use a common reference coordinate if provided, or use the first valid coordinate found</span>
        <span class="k">if</span> <span class="n">reference_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">common_ref_coord</span> <span class="o">=</span> <span class="n">reference_coord</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using provided reference coordinates for all channels: RA=</span><span class="si">{</span><span class="n">common_ref_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">common_ref_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Find the first valid reference coordinate</span>
            <span class="n">common_ref_coord</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">coords</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">reference_coords_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">common_ref_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using common reference coordinates for all channels: RA=</span><span class="si">{</span><span class="n">common_ref_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, DEC=</span><span class="si">{</span><span class="n">common_ref_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No valid reference coordinates found in any channel. Using local coordinates.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Save original attributes to restore later</span>
        <span class="n">original_wavelength_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span>
        <span class="n">original_wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span>
        <span class="n">original_cube_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span>
        
        <span class="c1"># Process each channel file to construct cubes</span>
        <span class="k">for</span> <span class="n">channel</span><span class="p">,</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="n">channel_files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constructing cube for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> from file: </span><span class="si">{</span><span class="n">file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Reset wavelength grid for this channel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="c1"># Construct cube for this channel</span>
            <span class="c1"># Use the channel from the filename as the channel identifier</span>
            <span class="n">cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_cube_from_rss_channel</span><span class="p">(</span>
                <span class="n">rss_file</span><span class="o">=</span><span class="n">file_path</span><span class="p">,</span>
                <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span>
                <span class="n">wavelength_range</span><span class="o">=</span><span class="n">wavelength_range</span><span class="p">,</span>
                <span class="n">dispersion</span><span class="o">=</span><span class="n">dispersion</span><span class="p">,</span>
                <span class="n">spatial_sampling</span><span class="o">=</span><span class="n">spatial_sampling</span><span class="p">,</span>
                <span class="n">reference_coord</span><span class="o">=</span><span class="n">common_ref_coord</span> <span class="ow">or</span> <span class="n">reference_coords_map</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
            <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">cube</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">channel_cubes</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">cube</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully constructed cube for channel: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="c1"># Store the wavelength grid that was created for this channel</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;channel_wavelength_grids&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;channel_wavelength_grids&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_wavelength_grids</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved wavelength grid for channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">: &quot;</span> 
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Å&quot;</span><span class="p">)</span>
                
                <span class="c1"># Store the WCS for this channel</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;channel_wcs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;channel_wcs&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span> <span class="o">=</span> <span class="p">{}</span>
                
                <span class="k">if</span> <span class="n">common_ref_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_wcs</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_wcs</span><span class="p">(</span><span class="n">common_ref_coord</span><span class="p">,</span> <span class="n">spatial_sampling</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to construct cube for channel: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Restore original attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavelength_grid</span> <span class="o">=</span> <span class="n">original_wavelength_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">original_wcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_data</span> <span class="o">=</span> <span class="n">original_cube_data</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channel_cubes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to construct any channel cubes&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully constructed cubes for channels: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">channel_cubes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">channel_cubes</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, LLAMAS Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>